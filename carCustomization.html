<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Car Customization - 5D</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #controls {
      position: absolute;
      top: 0;
      left: 0;
      padding: 20px;
      background-color: rgba(255, 255, 255, 0.8);
      z-index: 10;
      border-bottom-right-radius: 12px;
      max-width: 320px;
    }

    .controls button {
      display: block;
      margin-top: 10px;
      font-size: 16px;
    }

    .controls .control-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .controls .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.1);
      font-size: 0.75rem;
      margin-top: 6px;
    }

    #game-area {
      position: relative;
      width: 100%;
      height: 100vh;
      background-color: #eaeaea;
    }
  </style>
</head>
<body>
  <section id="controls" aria-label="Vehicle controls">
    <h2>üïπÔ∏è Garage Controls</h2>
    <p class="pill">Drive inside the garage, grab + drag to rotate, or toggle auto-loop.</p>
    <h4>üõª Maneuver Your Vehicle</h4>
    <div class="controls">
      <div class="control-row">
        <button id="left-btn">‚¨ÖÔ∏è Left</button>
        <button id="right-btn">‚û°Ô∏è Right</button>
        <button id="up-btn">‚¨ÜÔ∏è Accelerate</button>
        <button id="stop-btn">üõë Stop</button>
      </div>
      <h4>üé® Custom Tools</h4>
      <div class="control-row">
        <button id="paint-btn">üé® Paint</button>
        <button id="lights-btn">üí° Lights</button>
        <button id="spoiler-btn">ü™∂ Spoiler</button>
        <button id="loop-btn">üîÅ Auto Loop</button>
      </div>
      <button id="reset-btn">‚ôªÔ∏è Reset Position</button>
      <p class="pill">Parts: body, cabin, spoiler, lights, wheels.</p>
    </div>
  </section>

  <section id="game-area" aria-hidden="true"></section>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Setup scene, camera, and renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2f3438);
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Add lighting
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    light.castShadow = true;
    scene.add(light);

    const ambientLight = new THREE.AmbientLight(0x404040); // Soft lighting for shadows
    scene.add(ambientLight);

    const carGroup = new THREE.Group();
    scene.add(carGroup);

    // Car Geometry: Using Standard material for more realistic lighting effects
    const paints = [0x0077ff, 0xff3366, 0x14c38e, 0xffc300];
    let paintIndex = 0;
    const carMaterial = new THREE.MeshStandardMaterial({
      color: paints[paintIndex],
      metalness: 0.5,
      roughness: 0.35,
    });
    const carGeometry = new THREE.BoxGeometry(2, 0.5, 1);
    const car = new THREE.Mesh(carGeometry, carMaterial);
    car.castShadow = true;
    carGroup.add(car);

    const cabinGeometry = new THREE.BoxGeometry(1.1, 0.45, 0.9);
    const cabinMaterial = new THREE.MeshStandardMaterial({
      color: 0x222831,
      metalness: 0.2,
      roughness: 0.5,
    });
    const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
    cabin.position.set(-0.1, 0.45, 0);
    cabin.castShadow = true;
    carGroup.add(cabin);

    const spoilerGeometry = new THREE.BoxGeometry(0.7, 0.1, 0.35);
    const spoiler = new THREE.Mesh(spoilerGeometry, carMaterial);
    spoiler.position.set(-0.9, 0.35, 0);
    spoiler.castShadow = true;
    carGroup.add(spoiler);

    const lightGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.2);
    const lightMaterial = new THREE.MeshStandardMaterial({
      color: 0xfff3c2,
      emissive: 0xfff3c2,
      emissiveIntensity: 0.7,
    });
    const leftLight = new THREE.Mesh(lightGeometry, lightMaterial);
    const rightLight = new THREE.Mesh(lightGeometry, lightMaterial);
    leftLight.position.set(1.05, 0.05, 0.35);
    rightLight.position.set(1.05, 0.05, -0.35);
    carGroup.add(leftLight, rightLight);

    // Create wheels using better material
    const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.12, 32);
    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x1d1d1d, roughness: 0.6 });

    const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    const wheel3 = new THREE.Mesh(wheelGeometry, wheelMaterial);
    const wheel4 = new THREE.Mesh(wheelGeometry, wheelMaterial);

    // Adjust wheels' positions and rotations
    wheel1.position.set(-0.9, -0.3, 0.5);
    wheel2.position.set(0.9, -0.3, 0.5);
    wheel3.position.set(-0.9, -0.3, -0.5);
    wheel4.position.set(0.9, -0.3, -0.5);
    wheel1.rotation.z = Math.PI / 2;
    wheel2.rotation.z = Math.PI / 2;
    wheel3.rotation.z = Math.PI / 2;
    wheel4.rotation.z = Math.PI / 2;

    wheel1.castShadow = true;
    wheel2.castShadow = true;
    wheel3.castShadow = true;
    wheel4.castShadow = true;

    carGroup.add(wheel1, wheel2, wheel3, wheel4);

    const garage = new THREE.Group();
    scene.add(garage);

    const garageWidth = 18;
    const garageDepth = 24;
    const garageHeight = 6;

    // Garage floor
    const groundGeometry = new THREE.PlaneGeometry(garageWidth, garageDepth);
    const groundMaterial = new THREE.MeshStandardMaterial({
      color: 0x9ea4aa,
      roughness: 0.85,
      metalness: 0.05,
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.4;
    ground.receiveShadow = true;
    garage.add(ground);

    // Garage walls
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: 0xd8dde1,
      roughness: 0.7,
      metalness: 0.05,
    });
    const backWall = new THREE.Mesh(
      new THREE.PlaneGeometry(garageWidth, garageHeight),
      wallMaterial
    );
    backWall.position.set(0, garageHeight / 2 - 0.4, -garageDepth / 2);
    backWall.receiveShadow = true;
    garage.add(backWall);

    const leftWall = new THREE.Mesh(
      new THREE.PlaneGeometry(garageDepth, garageHeight),
      wallMaterial
    );
    leftWall.rotation.y = Math.PI / 2;
    leftWall.position.set(-garageWidth / 2, garageHeight / 2 - 0.4, 0);
    leftWall.receiveShadow = true;
    garage.add(leftWall);

    const rightWall = leftWall.clone();
    rightWall.rotation.y = -Math.PI / 2;
    rightWall.position.set(garageWidth / 2, garageHeight / 2 - 0.4, 0);
    garage.add(rightWall);

    // Garage ceiling
    const ceiling = new THREE.Mesh(
      new THREE.PlaneGeometry(garageWidth, garageDepth),
      new THREE.MeshStandardMaterial({
        color: 0xcfd6dc,
        roughness: 0.5,
        metalness: 0.1,
      })
    );
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.set(0, garageHeight - 0.4, 0);
    garage.add(ceiling);

    // Garage door panel
    const doorMaterial = new THREE.MeshStandardMaterial({
      color: 0xbfc6cd,
      roughness: 0.6,
      metalness: 0.2,
    });
    const door = new THREE.Mesh(
      new THREE.PlaneGeometry(garageWidth * 0.8, garageHeight * 0.7),
      doorMaterial
    );
    door.position.set(0, garageHeight * 0.35 - 0.4, garageDepth / 2 - 0.01);
    door.rotation.y = Math.PI;
    garage.add(door);

    // Floor markings
    const stripeMaterial = new THREE.MeshStandardMaterial({
      color: 0xf2f2f2,
      roughness: 0.6,
      metalness: 0.1,
    });
    const stripeGeometry = new THREE.PlaneGeometry(garageWidth * 0.6, 0.25);
    for (let i = -1; i <= 1; i += 1) {
      const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
      stripe.rotation.x = -Math.PI / 2;
      stripe.position.set(0, -0.39, i * 4);
      garage.add(stripe);
    }

    const overheadLight = new THREE.PointLight(0xffffff, 0.9, 30);
    overheadLight.position.set(0, garageHeight - 0.8, 2);
    overheadLight.castShadow = true;
    scene.add(overheadLight);

    // Camera position and settings
    camera.position.set(0, 2.2, 7);
    camera.lookAt(0, 0.2, 0);

    let carSpeed = 0;
    let carRotation = 0;
    const maxSpeed = 0.1;
    const acceleration = 0.002;
    const deceleration = 0.001;
    let autoLoop = false;
    let isDragging = false;
    let lastX = 0;
    let lightsOn = true;
    let spoilerOn = true;

    // Button controls for speed and direction
    document.getElementById('left-btn').addEventListener('click', () => {
      carRotation -= 0.05;
    });

    document.getElementById('right-btn').addEventListener('click', () => {
      carRotation += 0.05;
    });

    document.getElementById('up-btn').addEventListener('click', () => {
      if (carSpeed < maxSpeed) {
        carSpeed += acceleration;
      }
    });

    document.getElementById('stop-btn').addEventListener('click', () => {
      carSpeed = 0;
    });

    document.getElementById('paint-btn').addEventListener('click', () => {
      paintIndex = (paintIndex + 1) % paints.length;
      carMaterial.color.setHex(paints[paintIndex]);
    });

    document.getElementById('lights-btn').addEventListener('click', () => {
      lightsOn = !lightsOn;
      lightMaterial.emissiveIntensity = lightsOn ? 0.7 : 0.0;
    });

    document.getElementById('spoiler-btn').addEventListener('click', () => {
      spoilerOn = !spoilerOn;
      spoiler.visible = spoilerOn;
    });

    document.getElementById('loop-btn').addEventListener('click', () => {
      autoLoop = !autoLoop;
    });

    document.getElementById('reset-btn').addEventListener('click', () => {
      carGroup.position.set(0, 0, 0);
      carGroup.rotation.set(0, 0, 0);
      carRotation = 0;
      carSpeed = 0;
    });

    renderer.domElement.addEventListener('mousedown', (event) => {
      isDragging = true;
      lastX = event.clientX;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isDragging) {
        return;
      }
      const deltaX = event.clientX - lastX;
      lastX = event.clientX;
      carRotation += deltaX * 0.005;
    });

    const garageBounds = {
      minX: -garageWidth / 2 + 1.5,
      maxX: garageWidth / 2 - 1.5,
      minZ: -garageDepth / 2 + 2,
      maxZ: garageDepth / 2 - 2,
    };

    // Update loop with smooth movement and realistic car behavior
    function animate() {
      requestAnimationFrame(animate);

      const spinFactor = carSpeed * 25;
      wheel1.rotation.x -= spinFactor;
      wheel2.rotation.x -= spinFactor;
      wheel3.rotation.x -= spinFactor;
      wheel4.rotation.x -= spinFactor;

      if (autoLoop) {
        const time = performance.now() * 0.0005;
        carGroup.position.x = Math.cos(time) * 3;
        carGroup.position.z = Math.sin(time) * 5;
        carGroup.rotation.y = -time + Math.PI / 2;
      } else {
        // Smooth car rotation
        carGroup.rotation.y = THREE.MathUtils.lerp(carGroup.rotation.y, carRotation, 0.12);

        const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(
          new THREE.Vector3(0, 1, 0),
          carGroup.rotation.y
        );
        carGroup.position.addScaledVector(forward, carSpeed);

        if (carSpeed > 0) {
          carSpeed = Math.max(0, carSpeed - deceleration);
        }
      }

      // Clamp the car to the garage bounds
      carGroup.position.x = THREE.MathUtils.clamp(
        carGroup.position.x,
        garageBounds.minX,
        garageBounds.maxX
      );
      carGroup.position.z = THREE.MathUtils.clamp(
        carGroup.position.z,
        garageBounds.minZ,
        garageBounds.maxZ
      );

      // Render the scene
      renderer.render(scene, camera);
    }

    animate();

    // Handle window resizing
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
